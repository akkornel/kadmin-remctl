#!/usr/bin/perl -w
our $ID = q$Id$;
#
# kadmin-backend -- remctl interface to kadmin functionality.
#
# Written by Russ Allbery <rra@stanford.edu>
# Based heavily on work by Roland Schemers
# Copyright 2003, 2007 Board of Trustees, Leland Stanford Jr. University
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation, and that the name of Stanford University not be used in
# advertising or publicity pertaining to distribution of the software without
# specific, written prior permission.  Stanford University makes no
# representations about the suitability of this software for any purpose.  It
# is provided "as is" without express or implied warranty.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

##############################################################################
# Modules and declarations
##############################################################################

use strict;

use Expect ();

# K4 OPTIONS
our $K4_KADMIN = '/usr/local/sbin/kadmin';
our $K4_PRINC  = 'service.lsdb';
our $K4_SRVTAB = '/etc/leland/srvtab.lsdb';
our $K4_ADMIN  = 'admin';
our $K4_KEY    = '/db/srvtab/keys/admin';

# K5 OPTIONS
our $K5_KADMIN  = '/usr/local/sbin/k5admin';
our $K5_KPASSWD = '/usr/local/bin/kpasswd';
our $K5_PRINC   = 'service/lsdb';
our $K5_KEYTAB  = '/etc/leland/keytab.lsdb';

# Account used to test password strength.
our $STRENGTH   = 'service/password-strength';

# Path to kasetkey, used to create Kerberos v4 principals in an AFS kaserver.
our $KASETKEY   = '/usr/local/bin/gen_srvtab';

# Path to the ACL file of who can change passwords.
our $RESET_ACL  = '/etc/leland/remctl/kadmin-reset.acl';

# The help text.
our $HELP = <<'EOH';
Kerberos administrative remctl help:
  kadmin change_passwd <user> <old> <new>       Change password for <user>
  kadmin check_passwd <user> <password>         Check strength of password
  kadmin create <user> <pass> enabled|disabled  Create <user> account
  kadmin delete <user>                          Delete <user> account
  kadmin disable <user>                         Disable <user> account
  kadmin enable <user>                          Enable <user> account
  kadmin examine <user>                         Show information for <user>
  kadmin reset_passwd <user> <password>         Change password for <user>
EOH

##############################################################################
# Utility functions
##############################################################################

# Check a principal and make sure it's one that we're allowed to use.  The
# requirements are that the principal have a NULL instance, that it fit the
# form of a regular SUNet ID, and that it not be the special principal
# "admin".
sub check_principal {
    my ($principal) = @_;
    if ($principal !~ /^[a-z][0-9][a-z]{2,7}\z/ || $principal eq 'admin') {
        die "error: invalid principal: $principal\n";
    }
}

# Check if we can use a password.  We have to do a bit of sanity checking even
# though we're talking to Expect.
sub check_password {
    my ($password) = @_;
    if ($password =~ /[\x00-\x08\x0a-\x1f]/) {
        die "error: invalid control characters in password\n";
    }
}

# Spawn a conversation with k5admin and return an Expect object.
sub spawn_k5admin {
    my @args = ('-p', $K5_PRINC, '-k', '-t', $K5_KEYTAB);
    my $k5admin = Expect->spawn ($K5_KADMIN, @args);
    unless ($k5admin) {
        die "error: cannot run $K5_KADMIN\n";
    }
    return $k5admin;
}

# Run a k5admin command and capture the output.  Return a list consisting of
# the exit status and the output, or in a scalar context, just the exit
# status.
sub run_k5admin {
    my ($command) = @_;
    my @args = ('-p', $K5_PRINC, '-k', '-t', $K5_KEYTAB, '-q', $command);
    open (K5ADMIN, '-|', $K5_KADMIN, @args)
        or die "error: cannot run $K5_KADMIN\n";
    my @output = <K5ADMIN>;
    close K5ADMIN;
    my $status = ($? >> 8);
    if ($output[0] =~ /Authenticating as principal/) {
        shift @output;
    }
    return wantarray ? ($status, join ('', @output)) : $status;
}

##############################################################################
# Password changes and strength checking
##############################################################################

# The K5 kadmin interface doesn't support checking the strength of a password
# without trying to change a password.  We therefore test the strength of a
# password by changing the password of a designated special account (which is
# also set DISABLE_ALL_TIX) with the same password policy as our user accounts
# and seeing if the password is accepted.
#
# On success, do nothing.  On failure, die with the error message from K5
# kadmin.
sub validate_password {
    my ($password) = @_;
    check_password ($password);
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("change_password $STRENGTH\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'change_password: ', 'kadmin: ');
    if ($num == 1) {
        $after =~ s/ while changing.*//;
        print "retstr: $after\n";
        $k5admin->soft_close;
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Reset a password.  The only tricky part here is that we have to be sure that
# we're not resetting the password of a privileged account.  No user who can
# themselves reset passwords is allowed to have their password changed by this
# interface.  So first, we have to validate that.
sub reset_password {
    my ($principal, $password) = @_;
    check_principal ($principal);
    check_password ($password);

    # Check that the target principal isn't listed in the password change ACL.
    open (ACL, '<', $RESET_ACL) or die "error: cannot open $RESET_ACL: $!\n";
    local $_;
    while (<ACL>) {
        if (/^\Q$principal\E\@/) {
            die "error: password changes not permitted for that user\n";
        }
    }
    close ACL;

    # We're okay.  Do the password change.
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("change_password $principal\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'change_password: ', 'kadmin: ');
    if ($num == 1) {
        $after =~ s/ while changing.*//;
        print "retstr: $after\n";
        $k5admin->soft_close;
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Change a user's password given the old password.  We do this by spawning
# kpasswd and talking to it via Expect since that's the easiest way to make
# sure that we've validated the old password and everything is working
# properly.
sub change_password {
    my ($principal, $old, $new) = @_;
    check_principal ($principal);
    check_password ($old);
    check_password ($new);
    my $kpasswd = Expect->spawn ($K5_KPASSWD, $principal);
    unless ($kpasswd) {
        die "error: cannot run $K5_KPASSWD\n";
    }
    unless ($kpasswd->expect (2, '-re', 'Password for \S+: ')) {
        die "error: cannot talk to $K5_KPASSWD\n";
    }
    $kpasswd->send ($old);
    unless ($kpasswd->expect (2, 'Enter new password: ')) {
        die "error: cannot talk to $K5_KPASSWD\n";
    }
    $kpasswd->send ($new);
    unless ($kpasswd->expect (2, 'Enter it again: ')) {
        die "error: cannot talk to $K5_KPASSWD\n";
    }
    $kpasswd->send ($new);
    my ($num, $error, $match, $before, $after)
        = kpasswd->expect (2, 'Password change rejected: ',
                           'Password changed.');
    if ($num == 1) {
        print "retstr: $after\n";
        die "error: $after\n";
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $kpasswd->soft_close;
    }
}

##############################################################################
# Principal creation and deletion
##############################################################################

# Create a principal.  First, create a K4 account with a random password and
# set its status.  Then, create the account in K5, which will reset the
# password in K4.  The account creation will also queue a password change for
# AD.  Active Directory account creation is handled separately.  $status is
# either enabled or disabled and controls the initial account status.
sub create_principal {
    my ($principal, $password, $status) = @_;
    check_principal ($principal);
    check_password ($password);
    my $exist = run_k5admin ("getprinc $principal");
    if ($exist) {
        die "error: account $principal already exists\n";
    }
    my $code = system ($KASETKEY, '-k', $K4_KEY, '-a', $K4_ADMIN, '-r',
                       '-s', $principal);
    if ($code != 0) {
        die "error: cannot create K4 principal for $principal\n";
    }
    if ($status ne 'enabled') {
        my $code = system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB,
                           'disable', $principal);
        if ($code != 0) {
            die "error: cannot disable K4 principal for $principal\n";
        }
    }
    my $command = 'add_principal -policy standard +requires_preauth';
    if ($status ne 'enabled') {
        $command .= ' -allow_tix';
    }
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$command\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'add_principal: ', 'kadmin: ');
    if ($num == 1) {
        print "retstr: $after\n";
        $k5admin->soft_close;
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Delete a principal.  We're only responsible for removing the principal from
# Kerberos v4 and Kerberos v5.  Active Directory principal deletion is handled
# separately.
sub delete_principal {
    my ($principal) = @_;
    check_principal ($principal);
    system ($KASETKEY, '-k', $K4_KEY, '-a', $K4_ADMIN, '-D', $principal) == 0
        or die "error: cannot delete $principal in Kerberos v4\n";
    my ($status, $output) = run_k5admin ("delete $principal");
    if ($status != 0) {
        $output =~ s/^delete_principal: //;
        $output =~ s/\n.*//;
        die "error: $output\n";
    }
}

##############################################################################
# Enabling and disabling principals
##############################################################################

# Disable a principal.  This must be done separately in K5 and K4.
sub disable_principal {
    my ($principal) = @_;
    check_principal ($principal);
    my ($status, $output) = run_k5admin ("modprinc -allow_tix $principal");
    if ($status != 0) {
        $output =~ s/^modify_principal: //;
        $output =~ s/\n.*//;
        die "error: $output\n";
    }
    system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB, 'disable',
            $principal) == 0
        or die "error: cannot disable $principal in Kerberos v4\n";
}

# Enable a principal.  This must be done separately in K5 and K4.  Eventually,
# this should also check a database for locked status to prevent accounts from
# being enabled when we've administratively disabled them.
sub enable_principal {
    my ($principal) = @_;
    check_principal ($principal);
    my ($status, $output) = run_k5admin ("modprinc +allow_tix $principal");
    if ($status != 0) {
        $output =~ s/^modify_principal: //;
        $output =~ s/\n.*//;
        die "error: $output\n";
    }
    system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB, 'enable',
            $principal) == 0
        or die "error: cannot enable $principal in Kerberos v4\n";
}

##############################################################################
# Examining principals
##############################################################################

# Examine a principal.  We have to keep the format the same for right now or
# risk breaking Regadmin.  First, examine in Kerberos v4, and then examine in
# Kerberos v5.  Be sure that the two sections are separated by a line of 40
# dashes.
#
# This is the only place where we allow principals other than simple user
# principals with null instances, so we have to use a separate version of
# check_principal.  Principals with instances must be specified in the K5
# format and will be converted to K4.
sub examine_principal {
    my ($principal) = @_;
    unless ($principal =~ m%[a-zA-Z0-9]+(/[a-zA-Z0-9._-]+)\z%) {
        die "error: invalid character in principal name\n";
    }
    my $k4principal = $principal;
    $k4principal =~ s%(/[^.]+)\..*%$1%;
    $k4principal =~ s%/%.%;
    system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB, 'examine',
            $k4principal);
    print '-' x 40, "\n";
    my ($status, $output) = run_k5admin ("getprinc $principal");
    print $output;
}

##############################################################################
# Main routine
##############################################################################

my $cmd = shift;

if ($cmd eq 'change_passwd') {

    my $princ = shift or die "error: missing principal\n";
    my $old   = shift or die "error: missing old password\n";
    my $new   = shift or die "error: missing new password\n";

    change_password ($princ, $old, $new);

} elsif ($cmd eq 'check_passwd') {

    # The principal is accepted for compatibilty with older versions but
    # completely ignored.
    my $princ = shift;
    my $pass  = shift or die "error: missing password\n";

    validate_password ($pass);

} elsif ($cmd eq 'create') {

    my $princ  = shift or die "error: missing principal\n";
    my $pass   = shift or die "error: missing password\n";
    my $status = shift or die "error: missing enabled/disabled\n";
    if ($status ne 'enabled' && $status ne 'disabled') {
        die "error: invalid status: $status\n";
    }

    create_principal ($princ, $pass, $status);

} elsif ($cmd eq 'delete') {

    my $princ = shift or die "error: missing principal\n";

    delete_principal ($princ);

} elsif ($cmd eq 'disable') {

    my $princ = shift or die "error: missing principal\n";

    disable_principal ($princ);

} elsif ($cmd eq 'enable') {

    my $princ = shift or die "error: missing principal\n";

    enable_principal ($princ);

} elsif ($cmd eq 'examine') {

    my $princ = shift or die "error: missing principal\n";

    examine_principal ($princ);

} elsif ($cmd eq 'help') {

    print $HELP;

} elsif ($cmd eq 'reset_passwd' or $cmd eq 'reset') {

    my $princ = shift or die "error: missing principal\n";
    my $pass  = shift or die "error: missing password\n";

    reset_password ($princ, $pass);

} else {
    die "error: unknown cmd: $cmd\n";
}

exit 0;

##############################################################################
# Documentation
##############################################################################

=head1 NAME

kadmin-backend - remctl interface to kadmin functionality

=head1 SYNOPSIS

B<kadmin-backend> change_passwd I<user> I<old> I<new>

B<kadmin-backend> check_passwd I<user> I<password>

B<kadmin-backend> create I<user> I<password> (enabled | disabled)

B<kadmin-backend> (delete | disable | enable | examine) I<user>

B<kadmin-backend> (reset_passwd | reset) I<user> I<password>

=head1 DESCRIPTION

This script provides an interface to the same functionality provided by
B<kadmin>, but it also takes appropriate action to synchronize changes with
the AFS kaserver Kerberos v4 realm and with Active Directory where
appropriate or necessary.  It also provides some additional functions that
B<kadmin> doesn't provide directly.

All of these functions except for C<examine> only accept principals with no
instances or realms that fit the requirements for SUNet IDs (three to eight
characters starting with a lowercase letter and containing only digits and
lowercase letters).

The C<change_passwd> function changes a user's password given the current
password.  It is equivalent to B<kpasswd> but only works on the restricted
set of users as described above.

The C<check_passwd> function performs strength checking against the given
password without changing the password.  I<user> is required for backward
compatibility but is ignored.  This function will exit successfully (exit
status of 0) regardless of whether the password is acceptable; a non-zero
exit status is only used for an internal error.  If the password is
acceptable, there is no output; if the password is not acceptable, the
reason for its rejection is printed to standard output prefixed with
C<retstr:> and a space.

The C<create> function creates a new principal with the given password.  If
the third argument is C<enabled>, the new account is created enabled.  If
C<disabled>, the new account is created with DISALLOW_ALL_TIX set in
Kerberos v5 and NOTGS in the AFS kaserver.

The C<delete> function deletes the given principal from Kerberos v5 and the
AFS kaserver.

The C<disable> function sets DISALLOW_ALL_TIX on the principal in Kerberos
v5 and NOTGS in the AFS kaserver.

The C<enable> function clears DISALLOW_ALL_TIX on the principal in Kerberos
v5 and NOTGS in the AFS kaserver.

The C<examine> function prints out information about the principal in both
the AFS kaserver and Kerberos v5 environments.  This is the only function
that accepts principals with instances.  It attempts to convert principals
with an instance into their Kerberos v4 equivalent before looking them up in
the AFS kaserver.  The output format for the AFS kaserver is the same as the
old Kerberos v4 B<kadmin> output, and the output for Kerberos v5 is the
result of B<kadmin getprinc>.  A line of 40 dashes separates the first from
the second.

The C<help> function prints out a summary of supported commands and their
arguments.

The C<reset_passwd> function changes the password for a given principal
without requiring knowledge of the old password.  Changing the password of a
user who can themselves reset passwords is not permitted.  C<reset> is
supported as a synonym (used primarily with a separate password reset
service).

This script is normally run via B<remctld> with different ACLs on each
supported function.  C<reset_passwd> is a special case and should normally
be run via a separate instance of B<remctld> listening on a different port
and using a principal for authentication that disallows TGT-based service
tickets and has a short lifetime.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>

=cut
