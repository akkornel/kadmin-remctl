#!/usr/bin/perl -w
our $ID = q$Id$;
#
# kadmin-backend -- remctl interface to kadmin functionality.
#
# Written by Russ Allbery <rra@stanford.edu>
# Based heavily on work by Roland Schemers
# Copyright 2003, 2007 Board of Trustees, Leland Stanford Jr. University
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation, and that the name of Stanford University not be used in
# advertising or publicity pertaining to distribution of the software without
# specific, written prior permission.  Stanford University makes no
# representations about the suitability of this software for any purpose.  It
# is provided "as is" without express or implied warranty.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

##############################################################################
# Modules and declarations
##############################################################################

use strict;

use Expect ();
use MIME::Base64 qw(encode_base64);
use Text::Template ();

# Disable sending of kadmin's output to our standard output.
$Expect::Log_Stdout = 0;

# Temporary hack.
$ENV{LDAPCONF} = '/etc/krb5kdc/ldap.conf';

# K4 OPTIONS (set $K4_KADMIN to undef to disable K4)
our $K4_KADMIN = undef;
our $K4_PRINC  = undef;
our $K4_SRVTAB = undef;
our $K4_ADMIN  = undef;
our $K4_KEY    = undef;

# K5 OPTIONS
our $K5_KADMIN  = '/usr/local/sbin/k5admin';
our $K5_KPASSWD = '/usr/local/bin/kpasswd';
our $K5_PRINC   = 'service/lsdb';
our $K5_KEYTAB  = '/etc/leland/keytab.lsdb';

# Set this option to fake K4 examine output based on the K5 data.  This is
# only for backward compatibility for some systems at Stanford.
our $K4_FAKE    = undef;

# Account used to test password strength.
our $STRENGTH   = 'service/password-strength';

# Path to kasetkey, used to create Kerberos v4 principals in an AFS kaserver.
our $KASETKEY   = undef;

# Path to the ACL file of who can change passwords.
our $RESET_ACL  = '/etc/leland/remctl/kadmin-reset.acl';

# Reserved principal names.
our %RESERVED   = map { $_ => 1 } qw(admin kadmin krbtgt root service);

# Instance configuration.  Each key in this hash is an instance.  Each value
# is a hash with the following key/value pairs:
#
#     acl      => file listing principals that can manage this instance
#     checking => true if we should enable password strength checking
#     ldif     => Text::Template template used for account creation
#     reset    => true if we should allow password resets
#
# No instances are configured by default.
our %INSTANCES  = ();

# Load options from a configuration file, if present.
if (-r "/etc/kadmin-remctl.conf") {
    do "/etc/kadmin-remctl.conf"
        or die (($@ || $!) . "\n");
}

# The help text.
our $HELP = <<'EOH';
Kerberos administrative remctl help:
  kadmin change_passwd <user> <old> <new>       Change password for <user>
  kadmin check_passwd <user> <password>         Check strength of password
  kadmin create <user> <pass> enabled|disabled  Create <user> account
  kadmin delete <user>                          Delete <user> account
  kadmin disable <user>                         Disable <user> account
  kadmin enable <user>                          Enable <user> account
  kadmin examine <user>                         Show information for <user>
  kadmin instance check <user> <inst>           Whether <user>/<inst> exists
  kadmin instance create <user> <inst> <pass>   Create <user>/<inst> account
  kadmin instance delete <user> <inst>          Delete <user>/<inst> account
  kadmin instance list <inst>                   List all */<inst> accounts
  kadmin instance reset <user> <inst> <pass>    Set password for <user>/<inst>
  kadmin reset_passwd <user> <password>         Change password for <user>
EOH

##############################################################################
# Utility functions
##############################################################################

# Check whether a given principal is present in an ACL.  Returns true if so,
# false otherwise.
sub check_acl {
    my ($acl, $principal) = @_;
    open (ACL, '<', $acl) or die "error: cannot open $acl: $!\n";
    local $_;
    my $regex;
    if ($principal =~ /\@/) {
        $regex = qr/^\Q$principal\E\s/;
    } else {
        $regex = qr/^\Q$principal\E\@/;
    }
    while (<ACL>) {
        if (/$regex/) {
            return 1;
        }
    }
    close ACL;
    return;
}

# Check a principal and make sure it's one that we're allowed to use.  The
# requirements are that the principal have a NULL instance, that it fit the
# form of a regular SUNet ID, and that it not be the special principal
# "admin".
sub check_principal {
    my ($principal) = @_;
    if ($principal !~ /^[a-z][0-9a-z]{2,7}\z/ || $RESERVED{$principal}) {
        die "error: invalid principal: $principal\n";
    }
}

# Check an instance and make sure it's one we're allowed to use.  It must
# exist in the global instance hash and must be alphanumeric, and the account
# running this script must be permitted to manage it.
sub check_instance {
    my ($instance) = @_;
    if ($instance !~ /^[a-z][0-9a-z]*\z/ || !$INSTANCES{$instance}) {
        die "error: invalid instance: $instance\n";
    }
    if (!check_acl ($INSTANCES{$instance}{acl}, $ENV{REMUSER})) {
        die "error: $ENV{REMUSER} not allowed to manage $instance instances\n";
    }
}

# Check if we can use a password.  We have to do a bit of sanity checking even
# though we're talking to Expect.
sub check_password {
    my ($password) = @_;
    if ($password =~ /[\x00-\x08\x0a-\x1f]/) {
        die "error: invalid control characters in password\n";
    }
}

# Spawn a conversation with k5admin and return an Expect object.
sub spawn_k5admin {
    my @args = ('-p', $K5_PRINC, '-k', '-t', $K5_KEYTAB);
    my $k5admin = Expect->spawn ($K5_KADMIN, @args);
    unless ($k5admin) {
        die "error: cannot run $K5_KADMIN\n";
    }
    return $k5admin;
}

# Run a k5admin command and capture the output.  Return a list consisting of
# the exit status and the output, or in a scalar context, just the exit
# status.
sub run_k5admin {
    my ($command) = @_;
    my @args = ('-p', $K5_PRINC, '-k', '-t', $K5_KEYTAB, '-q', $command);
    my $pid = open (K5ADMIN, '-|');
    if (not defined $pid) {
        die "error: cannot fork: $!\n";
    } elsif ($pid == 0) {
        open (STDERR, '>&STDOUT') or die "error: cannot dup stdout: $!\n";
        exec ($K5_KADMIN, @args)
            or die "error: cannot run $K5_KADMIN\n";
    }
    local $_;
    my @output;
    while (<K5ADMIN>) {
        push (@output, $_) unless /Authenticating as principal/;
    }
    close K5ADMIN;
    my $status = ($? >> 8);
    return wantarray ? ($status, join ('', @output)) : $status;
}

##############################################################################
# Active Directory LDAP functions
##############################################################################

# Check whether an account already exists in Active Directory.  Takes the
# user and the instance and returns true if the user exists, false otherwise.
sub ad_ldap_exists {
    my ($user, $instance) = @_;
    if ($user =~ /[\'\\]/) {
        die "error: invalid user name $user\n";
    }
    my @command = ('k5start', '-Uqf', '/etc/krb5kdc/ad-keytab', '--',
                   'ldapsearch', '-Q', '-LLL');
    my $output = `@command samaccountname=${user}.${instance}`;
    return ($output ne '') ? 1 : undef;
}

# Create a new user account in Active Directory by instantiating the
# Text::Template template to create the LDIF and then passing that to ldapadd.
sub ad_ldap_create {
    my ($user, $instance, $password) = @_;
    my $source = $INSTANCES{$instance}{ldif};
    my $template = Text::Template->new (TYPE => 'FILE', SOURCE => $source)
        or die "error: could not create LDIF: $Text::Template::ERROR\n";
    my $b64pass = encode_base64 (qq{"$password"});
    chomp $b64pass;
    my %vars = (user     => $user,
                instance => $instance,
                password => $b64pass);
    my $result = $template->fill_in (HASH => \%vars);
    unless (defined $result) {
        die "error: could not create LDIF: $Text::Template::ERROR\n";
    }
    my @command = ('k5start', '-Uqf', '/etc/krb5kdc/ad-keytab', '--',
                   'ldapadd', '-Q');
    my $pid = open (ADD, '|-', @command);
    unless ($pid) {
        die "error: cannot execute ldapadd: $!\n";
    }
    print ADD $result;
    close ADD;
    if ($? != 0) {
        die "error: ldapadd of account to AD failed: $?\n";
    }
}

# Delete a user account out of Active Directory.  Takes the user and instance.
# In order to figure out the dn, we read the dn: line out of the LDIF file for
# this instance and then use Text::Template to build our DN.
sub ad_ldap_delete {
    my ($user, $instance) = @_;
    my $source = $INSTANCES{$instance}{ldif};
    open (SOURCE, '<', $source)
        or die "error: cannot open $source: $!\n";
    local $_;
    my $dn;
    while (<SOURCE>) {
        next unless /^dn:\s+/;
        $dn = $_;
        while (<SOURCE>) {
            last unless /^\s/;
            s/^\s+//;
            $dn .= $_;
        }
    }
    close SOURCE;
    die "error: cannot determine account DN for delete\n"
        unless $dn;
    my $template = Text::Template->new (TYPE => 'STRING', SOURCE => $dn)
        or die "error: cannot build DN template: $Text::Template::ERROR\n";
    my %vars = (user => $user, instance => $instance);
    my $dn = $template->fill_in (HASH => \%vars);
    unless (defined $dn) {
        die "error: cannot create DN: $Text::Template::ERROR\n";
    }
    my @command = ('k5start', '-Uqf', '/etc/krb5kdc/ad-keytab', '--',
                   'ldapdelete', '-Q');
    system (@command, $dn) == 0
        or die "error: ldapdelete of account in AD failed\n";
}

##############################################################################
# Password changes and strength checking
##############################################################################

# The K5 kadmin interface doesn't support checking the strength of a password
# without trying to change a password.  We therefore test the strength of a
# password by changing the password of a designated special account (which is
# also set DISABLE_ALL_TIX) with the same password policy as our user accounts
# and seeing if the password is accepted.
#
# On success, do nothing.  On failure, die with the error message from K5
# kadmin.
sub validate_password {
    my ($password) = @_;
    check_password ($password);
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("change_password $STRENGTH\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'change_password: ', 'kadmin: ');
    if ($num == 1) {
        $after =~ s/ while changing.*//s;
        warn "error: Insecure password rejected\n";
        print "retstr: Insecure password: $after\n";
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $k5admin->send ("change_password -randkey $STRENGTH\n");
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Reset a password.  The only tricky part here is that we have to be sure that
# we're not resetting the password of a privileged account.  No user who can
# themselves reset passwords is allowed to have their password changed by this
# interface.  So first, we have to validate that.
sub reset_password {
    my ($principal, $password) = @_;
    check_principal ($principal);
    check_password ($password);

    # Check that the target principal isn't listed in the password change ACL.
    if (check_acl ($RESET_ACL, $principal)) {
        warn "error: password changes not permitted for that user\n";
        exit 2;
    }

    # We're okay.  Do the password change.
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("change_password $principal\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'change_password: ', 'kadmin: ');
    if ($num == 1) {
        $after =~ s/ while changing.*//;
        print "error: $after\n";
        print "retstr: $after\n";
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
        exit 1;
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Change a user's password given the old password.  We do this by spawning
# kpasswd and talking to it via Expect since that's the easiest way to make
# sure that we've validated the old password and everything is working
# properly.
sub change_password {
    my ($principal, $old, $new) = @_;
    check_principal ($principal);
    check_password ($old);
    check_password ($new);
    my $kpasswd = Expect->spawn ($K5_KPASSWD, $principal);
    unless ($kpasswd) {
        die "error: cannot run $K5_KPASSWD\n";
    }
    unless ($kpasswd->expect (2, 'Password for')) {
        die "error: cannot talk to $K5_KPASSWD\n";
    }
    $kpasswd->send ($old . "\n");
    my ($num, $error, $match, $before, $after)
        = $kpasswd->expect (2, 'kpasswd: ', 'Enter new password: ');
    if ($num == 1) {
        $after =~ s/\r?\n.*//;
        print "retstr: $after\n";
        die "error: $after\n";
    } elsif ($error) {
        die "error: Expect said $error\n";
    }
    $kpasswd->send ($new . "\n");
    unless ($kpasswd->expect (2, 'Enter it again: ')) {
        die "error: cannot talk to $K5_KPASSWD\n";
    }
    $kpasswd->send ($new . "\n");
    ($num, $error, $match, $before, $after)
        = $kpasswd->expect (2, 'Password change rejected: ',
                            'Password changed.');
    if ($num == 1) {
        $after =~ s/\..*//;
        $after =~ s/\r?\n/ /g;
        $after =~ s/\s+See the kpasswd man page.*//;
        print "error: $after\n";
        print "retstr: $after\n";
        exit 1;
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $kpasswd->soft_close;
    }
}

##############################################################################
# Principal creation and deletion
##############################################################################

# Create a principal.  First, create a K4 account with a random password and
# set its status.  Then, create the account in K5, which will reset the
# password in K4.  The account creation will also queue a password change for
# AD.  Active Directory account creation is handled separately.  $status is
# either enabled or disabled and controls the initial account status.
sub create_principal {
    my ($principal, $password, $status) = @_;
    check_principal ($principal);
    check_password ($password);
    my (undef, $output) = run_k5admin ("getprinc $principal");
    if ($output !~ /does not exist/) {
        die "error: account $principal already exists\n";
    }
    if ($K4_KADMIN) {
        my $code = system ($KASETKEY, '-k', $K4_KEY, '-a', $K4_ADMIN, '-r',
                           '-s', $principal);
        if ($code != 0) {
            die "error: cannot create K4 principal for $principal\n";
        }
        if ($status ne 'enabled') {
            my $code = system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB,
                               'disable', $principal);
            if ($code != 0) {
                die "error: cannot disable K4 principal for $principal\n";
            }
        }
    }
    my $command = 'add_principal -policy standard +requires_preauth';
    if ($status ne 'enabled') {
        $command .= ' -allow_tix';
    }
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$command $principal\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'add_principal: ', 'kadmin: ');
    if ($num == 1) {
        $after =~ s/\r?\n.*//;
        print "retstr: $after\n";
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Delete a principal.  We're only responsible for removing the principal from
# Kerberos v4 and Kerberos v5.  Active Directory principal deletion is handled
# separately.
sub delete_principal {
    my ($principal) = @_;
    check_principal ($principal);
    if ($K4_KADMIN) {
        my @args = ('-k', $K4_KEY, '-a', $K4_ADMIN, '-D', $principal);
        system ($KASETKEY, @args) == 0
            or die "error: cannot delete $principal in Kerberos v4\n";
    }
    my ($status, $output) = run_k5admin ("delete_principal -force $principal");
    if ($status != 0 || $output =~ /^delete_principal: /) {
        $output =~ s/^delete_principal: //;
        $output =~ s/\r?\n.*//;
        die "error: $output\n";
    }
}

##############################################################################
# Enabling and disabling principals
##############################################################################

# Disable a principal.  This must be done separately in K5 and K4.
sub disable_principal {
    my ($principal) = @_;
    check_principal ($principal);
    my ($status, $output) = run_k5admin ("modprinc -allow_tix $principal");
    if ($status != 0 || $output =~ /^modify_principal: /) {
        $output =~ s/^modify_principal: //;
        $output =~ s/\r?\n.*//;
        die "error: $output\n";
    }
    if ($K4_KADMIN) {
        system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB, 'disable',
                $principal) == 0
            or die "error: cannot disable $principal in Kerberos v4\n";
    }
}

# Enable a principal.  This must be done separately in K5 and K4.  Eventually,
# this should also check a database for locked status to prevent accounts from
# being enabled when we've administratively disabled them.
sub enable_principal {
    my ($principal) = @_;
    check_principal ($principal);
    my ($status, $output) = run_k5admin ("modprinc +allow_tix $principal");
    if ($status != 0 || $output =~ /^modify_principal: /) {
        $output =~ s/^modify_principal: //;
        $output =~ s/\r?\n.*//;
        die "error: $output\n";
    }
    if ($K4_KADMIN) {
        system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB, 'enable',
                $principal) == 0
            or die "error: cannot enable $principal in Kerberos v4\n";
    }
}

##############################################################################
# Examining principals
##############################################################################

# Examine a principal.  We have to keep the format the same for right now or
# risk breaking Regadmin.  First, examine in Kerberos v4, and then examine in
# Kerberos v5.  Be sure that the two sections are separated by a line of 40
# dashes.
#
# This is the only place where we allow principals other than simple user
# principals with null instances, so we have to use a separate version of
# check_principal.  Principals with instances must be specified in the K5
# format and will be converted to K4.
sub examine_principal {
    my ($principal) = @_;
    unless ($principal =~ m%^[a-zA-Z0-9]+(/[a-zA-Z0-9._-]+)?\z%) {
        die "error: invalid character in principal name\n";
    }
    if ($K4_KADMIN) {
        my $k4principal = $principal;
        $k4principal =~ s%(/[^.]+)\..*%$1%;
        $k4principal =~ s%/%.%;
        system ($K4_KADMIN, '-p', $K4_PRINC, '-s', $K4_SRVTAB, 'examine',
                $k4principal);
        print '-' x 40, "\n";
    }
    my ($status, $output) = run_k5admin ("getprinc $principal");
    if ($K4_FAKE) {
        my $k4output;
        if ($output =~ /Principal does not exist while retrieving/) {
            $k4output = 'error: No such entry in the database';
        } else {
            if ($output =~ /DISALLOW_ALL_TIX/) {
                $k4output = "status: disabled\n";
            } else {
                $k4output = "status: enabled\n";
            }
            $k4output .= "account expiration: never\n";
            if ($output =~ /Last password change: (.*)/) {
                my $date = $1;
                $date =~ s/ \w{3} (\d{4})$/ $1/;
                $k4output .= "password last changed: $date\n";
            }
            if ($output =~ /Last modified: ([^\(\n]+?)\s+\(([^\)\n]+)\)/) {
                my ($date, $admin) = ($1, $2);
                $date =~ s/ \w{3} (\d{4})$/ $1/;
                $k4output .= "modification time: $date\n";
                $k4output .= "modified by: $admin\n";
            }
        }
        $output = $k4output . "\n" . ('-' x 40) . "\n" . $output;
    }
    print "retstr: $output";
}

##############################################################################
# Instance management
##############################################################################

# Check whether a given instance exists.
sub instance_check {
    my ($principal, $instance) = @_;
    check_principal ($principal);
    check_instance ($instance);
    my ($status, $output) = run_k5admin ("getprinc $principal/$instance");
    if ($output !~ /does not exist/) {
        print "$principal/$instance exists\n";
    } else {
        print "$principal/$instance does not exist\n";
        exit 1;
    }
}

# Create an instance for a given principal.  We do not create K4 accounts for
# instances, only K5.  Instances are always created enabled.
sub instance_create {
    my ($principal, $instance, $password) = @_;
    check_principal ($principal);
    check_instance ($instance);
    check_password ($password);
    my ($status, $output) = run_k5admin ("getprinc $principal/$instance");
    if ($output !~ /does not exist/) {
        die "error: account $principal/$instance already exists\n";
    }

    # Create the account in AD first so that password propagation works.  On
    # failure, we'll try to remove it again.
    unless (ad_ldap_exists ($principal, $instance)) {
        ad_ldap_create ($principal, $instance, $password);
    }

    # Do the account creation.  There is some code duplication with regular
    # account creation here.
    my $command = 'add_principal +requires_preauth';
    if ($INSTANCES{$instance}{checking}) {
        $command .= ' -policy standard';
    } else {
        $command .= ' -clearpolicy';
    }
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        ad_ldap_delete ($principal, $instance);
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$command $principal/$instance\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        ad_ldap_delete ($principal, $instance);
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        ad_ldap_delete ($principal, $instance);
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'add_principal: ', 'kadmin: ');
    if ($num == 1) {
        ad_ldap_delete ($principal, $instance);
        $after =~ s/\r?\n.*//;
        warn "error: $after\n";
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
        exit 1;
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

# Delete an instance for a given principal.  There is some code duplication
# here with regular account deletion.
sub instance_delete {
    my ($principal, $instance) = @_;
    check_principal ($principal);
    check_instance ($instance);
    if (ad_ldap_exists ($principal, $instance)) {
        ad_ldap_delete ($principal, $instance);
    }
    my $account = "$principal/$instance";
    my ($status, $output) = run_k5admin ("delete_principal -force $account");
    if ($status != 0 || $output =~ /^delete_principal: /) {
        $output =~ s/^delete_principal: //;
        $output =~ s/\r?\n.*//;
        die "error: $output\n";
    }
}

# List all accounts with a given instance.
sub instance_list {
    my ($instance) = @_;
    check_instance ($instance);
    my ($status, $output) = run_k5admin ("list_principals */$instance");
    if ($status != 0 || $output =~ /^list_principals: /) {
        $output =~ s/^list_principals: //;
        $output =~ s/\r?\n.*//;
        die "error: $output\n";
    } else {
        print $output;
    }
}

# Reset the password for an instance.  This is only allowed if the instance
# configuration says that password resets are acceptable.  There is some code
# duplication with regular password resets.
sub instance_reset {
    my ($principal, $instance, $password) = @_;
    check_principal ($principal);
    check_instance ($instance);
    check_password ($password);
    unless ($INSTANCES{$instance}{reset}) {
        die "error: password reset not permitted for $instance instances\n";
    }

    # We're okay.  Do the password change.
    my $k5admin = spawn_k5admin;
    unless ($k5admin->expect (2, 'kadmin:')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("change_password $principal/$instance\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    unless ($k5admin->expect (2, 'password for principal')) {
        die "error: cannot talk to $K5_KADMIN\n";
    }
    $k5admin->send ("$password\n");
    my ($num, $error, $match, $before, $after)
        = $k5admin->expect (2, 'change_password: ', 'kadmin: ');
    if ($num == 1) {
        $after =~ s/ while changing.*//;
        print "retstr: $after\n";
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    } elsif ($error) {
        die "error: Expect said $error\n";
    } else {
        $k5admin->send ("quit\n");
        $k5admin->soft_close;
    }
}

##############################################################################
# Main routine
##############################################################################

my $cmd = shift;

if ($cmd eq 'change_passwd') {

    my $princ = shift or die "error: missing principal\n";
    my $old   = shift or die "error: missing old password\n";
    my $new   = shift or die "error: missing new password\n";

    change_password ($princ, $old, $new);

} elsif ($cmd eq 'check_passwd') {

    # The principal is accepted for compatibilty with older versions but
    # completely ignored.
    my $princ = shift;
    my $pass  = shift or die "error: missing password\n";

    validate_password ($pass);

} elsif ($cmd eq 'create') {

    my $princ  = shift or die "error: missing principal\n";
    my $pass   = shift or die "error: missing password\n";
    my $status = shift or die "error: missing enabled/disabled\n";
    if ($status ne 'enabled' && $status ne 'disabled') {
        die "error: invalid status: $status\n";
    }

    create_principal ($princ, $pass, $status);

} elsif ($cmd eq 'delete') {

    my $princ = shift or die "error: missing principal\n";

    delete_principal ($princ);

} elsif ($cmd eq 'disable') {

    my $princ = shift or die "error: missing principal\n";

    disable_principal ($princ);

} elsif ($cmd eq 'enable') {

    my $princ = shift or die "error: missing principal\n";

    enable_principal ($princ);

} elsif ($cmd eq 'examine') {

    my $princ = shift or die "error: missing principal\n";

    examine_principal ($princ);

} elsif ($cmd eq 'help') {

    print $HELP;

} elsif ($cmd eq 'reset_passwd' or $cmd eq 'reset') {

    my $princ = shift or die "error: missing principal\n";
    my $pass  = shift or die "error: missing password\n";

    reset_password ($princ, $pass);

} elsif ($cmd eq 'instance') {

    my $subcmd = shift;

    if ($subcmd eq 'check') {

        my $princ = shift or die "error: missing principal\n";
        my $inst  = shift or die "error: missing instance\n";

        instance_check ($princ, $inst);

    } elsif ($subcmd eq 'create') {

        my $princ = shift or die "error: missing principal\n";
        my $inst  = shift or die "error: missing instance\n";
        my $pass  = shift or die "error: missing password\n";

        instance_create ($princ, $inst, $pass);

    } elsif ($subcmd eq 'delete') {

        my $princ = shift or die "error: missing principal\n";
        my $inst  = shift or die "error: missing instance\n";

        instance_delete ($princ, $inst);

    } elsif ($subcmd eq 'list') {

        my $inst  = shift or die "error: missing instance\n";

        instance_list ($inst);

    } elsif ($subcmd eq 'reset') {

        my $princ = shift or die "error: missing principal\n";
        my $inst  = shift or die "error: missing instance\n";
        my $pass  = shift or die "error: missing password\n";

        instance_reset ($princ, $inst, $pass);

    } else {
        die "error: unknown cmd: $cmd $subcmd\n";
    }
} else {
    die "error: unknown cmd: $cmd\n";
}

exit 0;

##############################################################################
# Documentation
##############################################################################

=head1 NAME

kadmin-backend - remctl interface to kadmin functionality

=head1 SYNOPSIS

B<kadmin-backend> change_passwd I<user> I<old> I<new>

B<kadmin-backend> check_passwd I<user> I<password>

B<kadmin-backend> create I<user> I<password> (enabled | disabled)

B<kadmin-backend> (delete | disable | enable | examine) I<user>

B<kadmin-backend> (reset_passwd | reset) I<user> I<password>

B<kadmin-backend> instance check I<user> I<instance>

B<kadmin-backend> instance create I<user> I<instance> I<password>

B<kadmin-backend> instance delete I<user> I<instance>

B<kadmin-backend> instance list I<instance>

B<kadmin-backend> instance reset I<user> I<instance> I<password>

=head1 DESCRIPTION

This script provides an interface to the same functionality provided by
B<kadmin>, but it also takes appropriate action to synchronize changes with
the AFS kaserver Kerberos v4 realm and with Active Directory where
appropriate or necessary.  It also provides some additional functions that
B<kadmin> doesn't provide directly and has separate functions for handling
account instances (principals in the form I<principal>/I<instance>).

All of these functions except for C<examine> and the C<instance> functions
only accept principals with no instances or realms that fit the requirements
for SUNet IDs (three to eight characters starting with a lowercase letter
and containing only digits and lowercase letters).  C<instance> functions
require a principal that fits the requirements for a SUNet ID and an
instance that starts with a letter and contains only lowercase alphanumeric
characters.  Principals may also be rejected if they're reserved, and
explicit configuration is required for each instance.

The C<instance> functions should only be used to manage instances that have
regular passwords.  Instances used by automated processes via keytabs should
be managed via a different mechanism.  All C<instance> functions do
additional ACL checking beyond the authorization rules of B<remctld> to
verify that the remote user is allowed to manage that particular instance.

The C<change_passwd> function changes a user's password given the current
password.  It is equivalent to B<kpasswd> but only works on the restricted
set of users as described above.

The C<check_passwd> function performs strength checking against the given
password without changing the password.  I<user> is required for backward
compatibility but is ignored.  This function will exit successfully (exit
status of 0) regardless of whether the password is acceptable; a non-zero
exit status is only used for an internal error.  If the password is
acceptable, there is no output; if the password is not acceptable, the
reason for its rejection is printed to standard output prefixed with
C<retstr:> and a space.

The C<create> function creates a new principal with the given password.  If
the third argument is C<enabled>, the new account is created enabled.  If
C<disabled>, the new account is created with DISALLOW_ALL_TIX set in
Kerberos v5 and NOTGS in the AFS kaserver.

The C<delete> function deletes the given principal from Kerberos v5 and the
AFS kaserver.

The C<disable> function sets DISALLOW_ALL_TIX on the principal in Kerberos
v5 and NOTGS in the AFS kaserver.

The C<enable> function clears DISALLOW_ALL_TIX on the principal in Kerberos
v5 and NOTGS in the AFS kaserver.

The C<examine> function prints out information about the principal in both
the AFS kaserver and Kerberos v5 environments.  This is the only function
that accepts principals with instances.  It attempts to convert principals
with an instance into their Kerberos v4 equivalent before looking them up in
the AFS kaserver.  The output format for the AFS kaserver is the same as the
old Kerberos v4 B<kadmin> output, and the output for Kerberos v5 is the
result of B<kadmin getprinc>.  A line of 40 dashes separates the first from
the second.

The C<help> function prints out a summary of supported functions and their
arguments.

The C<reset_passwd> function changes the password for a given principal
without requiring knowledge of the old password.  Changing the password of a
user who can themselves reset passwords is not permitted.  C<reset> is
supported as a synonym (used primarily with a separate password reset
service).

The C<instance check> function prints a message and returns 0 if that
combination of principal and instance exists, or a different message and
returns 1 if the instance does not exist.

The C<instance create> function creates a new I<principal>/I<instance>
Kerberos principal, provided that it doesn't already exist, and sets its
password to the provided password.  This principal may or may not have
password checking enabled, depending on the configuration for that instance.

The C<instance delete> function deletes a I<principal>/I<instance> Kerberos
principal.

The C<instance list> function lists all Kerberos principals with the given
instance.  Note that this list may contain service principals and other
reserved principals that cannot be managed through this interface.

The C<instance reset> function resets the password for a given
I<principal>/I<instance> Kerberos principal, provided that password resets
are allowed for that instance type in the B<kadmin-remctl> configuration.

This script is normally run via B<remctld> with different ACLs on each
supported function.  C<reset_passwd> is a special case and should normally
be run via a separate instance of B<remctld> listening on a different port
and using a principal for authentication that disallows TGT-based service
tickets and has a short lifetime.

=head1 CONFIGURATION

If the file F</etc/kadmin-remctl.conf> exists, B<kadmin-remctl> will load it
after setting its configuration defaults.  This file can therefore be used
to override any defaulit in B<kadmin-remctl>.  The configuration file must
be valid Perl syntax and should normally consist only of variable settings.
The following Perl variables may be set:

=over 4

=item %INSTANCES

Configuration for which instances can be managed through the C<instance>
functions and what constraints are placed on how they're managed.  Each key
should be the name of an instance.  Each value should be a hash containing
one or more of the following keys:

=over 2

=item acl

The value is the ACL file listing the principals that can manage instances
of this type.  This option must be set and should contain a simple list of
fully-qualified principals, one per line.

=item checking

Set to a true value if passwords for this instance should be subject to
password strength checking, false otherwise.

=item reset

Set to a true value if B<kadmin-remctl> should support resetting passwords
for this instance (via the C<instance reset> function), false otherwise.

=back

=item $K4_KADMIN

Full path to the Kerberos v4 B<kadmin> command-line utility.  Note that
B<kadmin-remctl> expects a Stanford-specific B<kadmin> and this may
therefore not be that useful for other sites.

If this is set to undef, all Kerberos v4 actions will be skipped and this
script will deal purely with Kerberos v5.

=item $K4_PRINC

Principal to use for K4 B<kadmin> authentication.

=item $K4_SRVTAB

Srvtab to use for K4 B<kadmin> authentication.

=item $K4_ADMIN

Principal to use for creating and modifying principals in an AFS kaserver
(used for the operations that can't be done via B<kadmin>).

=item $K4_KEY

Srvtab to use for direct AFS kaserver operations.

=item $K5_KADMIN

Path to the regular Kerberos v5 B<kadmin> command-line client.  Most
operations are done by running this client interactively under Expect.

=item $K5_KPASSWD

Path to the Kerberos v5 B<kpasswd> command-line client, which is used to
implement the C<change_passwd> function.

=item $K5_PRINC

Principal to use for authentication of Kerberos v5 B<kadmin> operations.

=item $K5_KEYTAB

Keytab to use for authentication of Kerberos v5 B<kadmin> operations.

=item $KASETKEY

Path to B<kasetkey>, used to make changes to an AFS kaserver that can't be
done via the Kerberos v4 B<kadmin> program.

=item %RESERVED

A hash of reserved principal names (without instances).  The keys are the
principals; the value should be any true value.  If a principal is present
in this hash, B<kadmin-remctl> will refuse to perform any operation on that
principal or any of its instances.  You can either reset this hash
completely in the configuration file (if you do, be careful of principals
like C<kadmin> and C<krbtgt>) or add additional principals to it.

=item $RESET_ACL

Path to the ACL file controlling who can change passwords for other users.
B<kadmin-remctl> checks the principal for which a password is being changed
against this file and refuses password changes if the target principal is
listed in this file.  This ensures that people who can change others'
passwords cannot themselves have their password changed through that route,
preventing privilege escalation.

=item $STRENGTH

The Kerberos principal used for strength checking.  When checking the
strength of a password (the C<check_passwd> function), B<kadmin-remctl>
attempts to change the password of this principal.  This principal should
therefore be set DISALLOW_ALL_TIX and not be used on any ACLs, since any
user with access to the C<check_passwd> function can change its password to
anything they choose.

=back

For the defaults, see the beginning of the kadmin-backend script.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>

=cut
